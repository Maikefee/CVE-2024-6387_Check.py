import socket
import argparse
import threading
from queue import Queue
from concurrent.futures import ThreadPoolExecutor
from tqdm import tqdm  # 进度条库

def is_port_open(ip, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(1)
    try:
        sock.connect((ip, port))
        sock.close()
        return True
    except:
        return False

def get_ssh_banner(ip, port):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(2)
        sock.connect((ip, port))
        banner = sock.recv(1024).decode().strip()
        sock.close()
        return banner
    except Exception as e:
        return str(e)

def check_vulnerability(ip, port, result_queue, progress):
    if not is_port_open(ip, port):
        result_queue.put((ip, port, 'closed', "Port closed"))
    else:
        banner = get_ssh_banner(ip, port)
        if "SSH-2.0-OpenSSH" not in banner:
            result_queue.put((ip, port, 'failed', f"Failed to retrieve SSH banner: {banner}"))
        else:
            vulnerable_versions = [
                'SSH-2.0-OpenSSH_8.5p1', 'SSH-2.0-OpenSSH_8.6p1',
                'SSH-2.0-OpenSSH_8.7p1', 'SSH-2.0-OpenSSH_8.8p1',
                'SSH-2.0-OpenSSH_8.9p1', 'SSH-2.0-OpenSSH_9.0p1',
                'SSH-2.0-OpenSSH_9.1p1', 'SSH-2.0-OpenSSH_9.2p1',
                'SSH-2.0-OpenSSH_9.3p1', 'SSH-2.0-OpenSSH_9.4p1',
                'SSH-2.0-OpenSSH_9.5p1', 'SSH-2.0-OpenSSH_9.6p1',
                'SSH-2.0-OpenSSH_9.7p1'
            ]
            if any(version in banner for version in vulnerable_versions):
                result_queue.put((ip, port, 'vulnerable', f"(running {banner})"))
            else:
                result_queue.put((ip, port, 'not_vulnerable', f"(running {banner})"))

    progress.update(1)

def main():
    parser = argparse.ArgumentParser(description="Check if servers are running a vulnerable version of OpenSSH.")
    parser.add_argument("file", help="Path to a file containing IP addresses and ports in the format IP:PORT.")
    
    args = parser.parse_args()
    file_path = args.file

    targets = []
    try:
        with open(file_path, 'r') as file:
            targets = [line.strip() for line in file if line.strip()]
    except IOError:
        print(f"❌ [-] Unable to read file: {file_path}")
        return

    result_queue = Queue()
    total_targets = len(targets)
    progress = tqdm(total=total_targets, desc="Scanning", unit="target")

    # 使用线程池来限制并发线程数
    with ThreadPoolExecutor(max_workers=100) as executor:
        for target in targets:
            try:
                ip, port = target.split(':')
                port = int(port)
            except ValueError:
                print(f"❌ [-] Invalid target format: {target}")
                continue

            executor.submit(check_vulnerability, ip, port, result_queue, progress)

    total_scanned = len(targets)
    closed_ports = 0
    not_vulnerable = []
    vulnerable = []

    while not result_queue.empty():
        ip, port, status, message = result_queue.get()
        if status == 'closed':
            closed_ports += 1
        elif status == 'vulnerable':
            vulnerable.append((ip, message))
            print(f"🚨 [+] Vulnerable server at {ip} {message}")
        elif status == 'not_vulnerable':
            not_vulnerable.append((ip, message))
            print(f"🛡️ [+] Not vulnerable server at {ip} {message}")
        else:
            print(f"⚠️ [!] Server at {ip}:{port} is {message}")

    # 将存在漏洞的服务器保存到文件
    with open("alivessh.txt", "w") as f:
        for ip, msg in vulnerable:
            f.write(f"{ip} {msg}\n")

    progress.close()
    
    print(f"\n🛡️ Servers not vulnerable: {len(not_vulnerable)}\n")
    for ip, msg in not_vulnerable:
        print(f"   [+] Server at {ip} {msg}")
    print(f"\n🚨 Servers likely vulnerable: {len(vulnerable)}\n")
    for ip, msg in vulnerable:
        print(f"   [+] Server at {ip} {msg}")
    print(f"\n🔒 Servers with port closed: {closed_ports}")
    print(f"\n📊 Total scanned targets: {total_scanned}\n")

if __name__ == "__main__":
    main()
