import socket
import argparse
import threading
from queue import Queue
from concurrent.futures import ThreadPoolExecutor
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def is_port_open(ip, port):
    """æ£€æŸ¥æŒ‡å®šIPå’Œç«¯å£æ˜¯å¦å¼€æ”¾"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(1)
    try:
        sock.connect((ip, port))
        sock.close()
        logging.info(f"{ip}:{port} is open")
        return True
    except Exception as e:
        logging.info(f"{ip}:{port} is closed or not reachable: {e}")
        return False

def get_ssh_banner(ip, port):
    """è·å–SSHæœåŠ¡çš„bannerä¿¡æ¯"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(2)
        sock.connect((ip, port))
        banner = sock.recv(1024).decode().strip()
        sock.close()
        logging.info(f"{ip}:{port} banner: {banner}")
        return banner
    except Exception as e:
        logging.error(f"Error retrieving banner from {ip}:{port}: {e}")
        return str(e)

def check_vulnerability(ip, port, vulnerable_versions, result_queue, alive_ips):
    """æ£€æŸ¥æŒ‡å®šIPå’Œç«¯å£çš„SSHç‰ˆæœ¬æ˜¯å¦æ˜“å—æ”»å‡»"""
    if not is_port_open(ip, port):
        result_queue.put((ip, port, 'closed', "Port closed"))
        return

    banner = get_ssh_banner(ip, port)
    if not banner or "SSH-2.0-OpenSSH" not in banner:
        result_queue.put((ip, port, 'failed', f"Failed to retrieve SSH banner: {banner}"))
        return

    alive_ips.append(f"{ip}:{port}")

    if any(version in banner for version in vulnerable_versions):
        result_queue.put((ip, port, 'vulnerable', f"(running {banner})"))
    else:
        result_queue.put((ip, port, 'not_vulnerable', f"(running {banner})"))

def main():
    parser = argparse.ArgumentParser(description="Batch check if servers are running a vulnerable version of OpenSSH.")
    parser.add_argument("targets", help="File path containing IP addresses and ports in IP:PORT format.")
    parser.add_argument("--threads", type=int, default=10, help="Number of threads to use for scanning (default: 10).")

    args = parser.parse_args()
    target_file = args.targets
    num_threads = args.threads

    # å®šä¹‰æ˜“å—æ”»å‡»çš„OpenSSHç‰ˆæœ¬
    vulnerable_versions = [
        'SSH-2.0-OpenSSH_8.5p1',
        'SSH-2.0-OpenSSH_8.6p1',
        'SSH-2.0-OpenSSH_8.7p1',
        'SSH-2.0-OpenSSH_8.8p1',
        'SSH-2.0-OpenSSH_8.9p1',
        'SSH-2.0-OpenSSH_9.0p1',
        'SSH-2.0-OpenSSH_9.1p1',
        'SSH-2.0-OpenSSH_9.2p1',
        'SSH-2.0-OpenSSH_9.3p1',
        'SSH-2.0-OpenSSH_9.4p1',
        'SSH-2.0-OpenSSH_9.5p1',
        'SSH-2.0-OpenSSH_9.6p1',
        'SSH-2.0-OpenSSH_9.7p1'
    ]

    ips = []
    with open(target_file, 'r') as file:
        ips = [line.strip() for line in file if ':' in line]

    result_queue = Queue()
    alive_ips = []

    with ThreadPoolExecutor(max_workers=num_threads) as executor:
        for ip_port in ips:
            ip, port = ip_port.split(':')
            port = int(port)
            executor.submit(check_vulnerability, ip, port, vulnerable_versions, result_queue, alive_ips)

    total_scanned = len(ips)
    closed_ports = 0
    not_vulnerable = []
    vulnerable = []

    while not result_queue.empty():
        ip, port, status, message = result_queue.get()
        if status == 'closed':
            closed_ports += 1
        elif status == 'vulnerable':
            vulnerable.append((ip, port, message))
        elif status == 'not_vulnerable':
            not_vulnerable.append((ip, port, message))
        else:
            logging.warning(f"Server at {ip}:{port} is {message}")

    logging.info(f"\nğŸ›¡ï¸ Servers not vulnerable: {len(not_vulnerable)}\n")
    for ip, port, msg in not_vulnerable:
        logging.info(f"   [+] Server at {ip}:{port} {msg}")
    logging.info(f"\nğŸš¨ Servers likely vulnerable: {len(vulnerable)}\n")
    for ip, port, msg in vulnerable:
        logging.info(f"   [+] Server at {ip}:{port} {msg}")
    logging.info(f"\nğŸ”’ Servers with port closed: {closed_ports}")
    logging.info(f"\nğŸ“Š Total scanned targets: {total_scanned}\n")

    # å°†å­˜æ´»çš„IPå’Œç«¯å£ä¿å­˜åˆ°alive.txtæ–‡ä»¶ä¸­
    with open('alive.txt', 'w') as alive_file:
        for ip_port in alive_ips:
            alive_file.write(ip_port + '\n')

if __name__ == "__main__":
    main()